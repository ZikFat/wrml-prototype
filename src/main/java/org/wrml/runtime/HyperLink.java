/**
 * Copyright (C) 2011 WRML.org <mark@wrml.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.wrml.runtime;

import java.io.Serializable;
import java.net.URI;
import java.util.Map;

import org.wrml.Model;
import org.wrml.event.LinkEventListener;
import org.wrml.model.api.LinkTemplate;
import org.wrml.model.schema.Link;
import org.wrml.model.schema.LinkRelation;
import org.wrml.service.Service;
import org.wrml.util.MediaType;
import org.wrml.util.observable.ObservableMap;
import org.wrml.util.transformer.Transformer;

/**
 * A Model instance's Link. This class represents a link "instance", that is
 * a
 * link with a fully qualified href URI value that can be used to interact.
 * 
 * A link is enabled if the Model's schema's associated link formula
 * evaluates
 * to true. Instances of this class are responsible for managing their
 * enabled
 * state changes by listening to events from the fields that their
 * LinkFormula
 * relies upon.
 */
public final class HyperLink implements Serializable {

    private static final long serialVersionUID = -6235652220661484935L;

    private final Model _Referrer;
    private final URI _Rel;
    private URI _Href;
    private boolean _Enabled;

    public HyperLink(Model referrer, URI rel) {
        _Referrer = referrer;
        _Rel = rel;
    }

    public void addEventListener(LinkEventListener listener) {
        // TODO Add an event listener
    }

    public Object click(MediaType responseType, Object requestEntity, Map<String, String> hrefParams) {

        // TODO: Fire the pre-Click Event

        /*
         * Autogenerated subclasses of Model can have an generated method
         * for
         * each combination of link relation and request/response Schema.
         * Sort
         * of like Hibernate for the Web.
         * 
         * For example, this approach would imply that subclasses that
         * "implement" WRML's Document schema would have a getSelf() method
         * in
         * Java, which under the covers would click a link to return the
         * latest
         * version of the object.
         * ...Okay perhaps and odd example to start with.
         * 
         * This method is made possible because of the metadata provided by
         * the
         * LinkRelation, which details the name, the possible return types
         * (as
         * schema ids within response media types), and optional request
         * types
         * (as schema ids within request media types). This information can
         * be
         * used at class generation time to produce methods that have names
         * like
         * save or save(Story story) and getAuthor(). JavaBean method names
         * are
         * generated from concat of link rel's method, name, and return
         * schema
         * (if needed to disambiguate). For example WRML's:
         * 
         * "GET author com/example/Author"
         * 
         * turns into Java's:
         * 
         * "public Author getAuthor()".
         * 
         * 
         * Other methods might look like:
         * 
         * 
         * The LinkRelation specified two (or more) response schema types,
         * "Writer" being one of them. Java doesn't allow overloading the
         * return
         * type of methods, so we need to alter the name too.
         * 
         * public Writer getAuthorAsWriter();
         * 
         * See bad first example above public Story getSelf();
         * 
         * This could be an interesting way of representing Web collections
         * ...
         * 
         * public org.wrml.Collection<Story> getParent();
         * 
         * In cases where the LinkRelation accepts a request schema type
         * that
         * this schema instance implements, the code generation should
         * provide a
         * no-arg version of the method that internally passes this Model
         * (the
         * Link's owner). This would allow the JavaBean interface to have
         * methods like save() which internally "PUT" the Model to its
         * corresponding service and return the origin's version for model
         * syncing.
         * 
         * public Story save();
         * 
         * Is it possible to determine the URI template vars names that are
         * left
         * over after the source schema fills in params with field values?
         * It
         * would be cool if they could be used to generate clean params
         * names
         * for Java methods that need to result in a client-controlled
         * resource
         * name (with initial PUT)
         * 
         * public Story save(String name);
         * 
         * A self destruct button
         * 
         * public void delete();
         * 
         * An "unsafe" action (aka controller) method that was generated
         * from a
         * link rel that uses POST.
         * 
         * public void makeRocketGoNow();
         * 
         * These methods further extend the data available to clients using
         * the
         * JavaBean interface of Models by providing access to linked data
         * via
         * simple get methods. This simplified access to the resource model
         * would be really slick in a dynamic language like groovy talking
         * directly to a REST API via WRML, with object caching in the JVM
         * of
         * course.
         * 
         * At Link.click time, under the covers, these generated methods
         * traverse the linkage using the very same metadata to make the
         * appropriate request to the appropriate service. This is RESTful.
         * 
         * Finally, the role of the service is to be the beginning of both
         * the
         * client-side API and the Service interface. By making the
         * services available for look-up based on schema id, context
         * implementations can choose to register one service per type or
         * services that support several different types. This design allows
         * for
         * the same context interface to work for both client and server
         * side
         * uses of this class. On the client side, the context is perhaps an
         * abstraction over some HTTP client making REST API calls. On the
         * server side, the context may talk to a storage subsystem to CRUD
         * wrml
         * objects (backend connection). Its WRML's equivalent of the Web's
         * uniform interface.
         */

        // Check to see if this link is currently enabled before proceeding
        if (!isEnabled()) {
            // TODO: Should null represent a disconnected or disabled link?
            return null;
        }

        /*
         * TODO: Handle non-WRML model Links to exchange raw input/output
         * streams. Use the MediaType to look up a stream handler that is
         * configured in the Context (like services or possibly just use
         * services)
         * 
         * MediaType requestMediaType = null;
         * 
         * if (requestModel != null) { // TODO: // Determine default media
         * type
         * by looking at the link template and // then the link relation. //
         * Go
         * through each list comparing the requestModel's schema URI to //
         * the
         * wrml media type's schema parameter, or if a non wrml media //
         * type is
         * used then look up a Format using the "raw" media type // (e.g.
         * application/json maps to the json Format) }
         */

        final Model referrer = getReferrer();
        final Context context = referrer.getContext();

        if ((responseType != null) && !isGeneratableResponseType(responseType)) {
            // TODO: Preemptively throw "406 Not Acceptable" exception

            // TODO: Give the alert an ID?
            //Alert alert = context.createModel(Alert.class, null, );

            return null;
        }

        MediaType requestType = null;

        if (requestEntity != null) {

            final Transformer<MediaType, Class<?>> mediaTypeToClassTransformer = context
                    .getMediaTypeToClassTransformer();
            requestType = mediaTypeToClassTransformer.bToA(requestEntity.getClass());

            if ((requestType != null) && !isSupportedRequestType(requestType)) {
                // TODO: Preemptively throw "415 Unsupported Media Type" exception
                return null;
            }
        }

        final Service responseTypeService = context.getService(responseType);

        // TODO: The last minute hrefParams is a possibly half-baked way to fill
        // in any remaining URI Template params, such as the client-assigned
        // "name" of a first time stored (PUT) resource.
        final URI href = getHref(hrefParams);

        Object responseEntity = null;

        final LinkRelation rel = getLinkRelation();
        final org.wrml.util.http.Method method = rel.getMethod();
        switch (method) {

        // TODO: Handle collections here?

        case GET:
            responseEntity = responseTypeService.get(href, null, responseType, referrer);
            break;

        case PUT:
            responseEntity = responseTypeService.put(href, requestEntity, responseType, referrer);
            break;

        case DELETE:
            responseEntity = responseTypeService.remove(href, responseType, referrer);
            break;

        case POST:
            // TODO: Create or Execute? 
            // Look at params to decide? Look at endpoint's resource archetype?

            break;

        case HEAD:
            // TODO: Handle HTTP HEAD
            responseEntity = responseTypeService.get(href, null, responseType, referrer);
            break;

        case OPTIONS:
            // TODO: Handle HTTP OPTIONS
            responseEntity = responseTypeService.get(href, null, responseType, referrer);
            break;

        default:

            /*
             * TODO: Throw "405 Method Not Allowed"
             */

            break;
        }

        // TODO: Fire the post-Click Event

        return responseEntity;
    }

    public void fireHrefChangedEvent() {

    }

    public URI getHref() {
        return _Href;
    }

    public Link getLink() {
        final Model referrer = getReferrer();
        final Context context = referrer.getContext();
        final Prototype prototype = context.getPrototype(referrer.getMediaType());

        final ObservableMap<URI, Link> links = prototype.getLinksByRel();
        final URI rel = getLinkRelationId();
        return ((links != null) && links.containsKey(rel)) ? links.get(rel) : null;
    }

    public LinkRelation getLinkRelation() {
        final Model referrer = getReferrer();
        final Context context = referrer.getContext();
        final MediaType linkRelationMediaType = context.getMediaTypeToClassTransformer().bToA(LinkRelation.class);
        final Service service = context.getService(linkRelationMediaType);
        return (LinkRelation) ((Model) service.get(getLinkRelationId(), null, linkRelationMediaType, referrer))
                .getStaticInterface();
    }

    public URI getLinkRelationId() {
        return _Rel;
    }

    public LinkTemplate getLinkTemplate() {

        return null;

        // TODO Get the LinkTemplate from the API

        //        final Model owner = getOwner();
        //
        //        if (!(owner instanceof Document)) {
        //            return null;
        //        }
        //
        //        final Document document = (Document) owner;
        //        final ResourceTemplate resourceTemplate = document.getResourceTemplate();
        //
        //        final ObservableMap<URI, URI> hereToThereLinkRelationIdToLinkTemplateIdMap = resourceTemplate
        //                .getEndPointLinkRelationIdToLinkTemplateIdMap();
        //
        //        final URI linkTemplateId = hereToThereLinkRelationIdToLinkTemplateIdMap.get(getLinkRelationId());
        //
        //        Context context = owner.getContext();
        //        Service service = context.getService(LinkTemplate.class);
        //        return (LinkTemplate) service.get(linkTemplateId, document);

    }

    public Model getReferrer() {
        return _Referrer;
    }

    public boolean isEnabled() {
        return _Enabled;
    }

    /**
     * 
     * @param hrefParams
     *            The unfinished URI template params for HTTP methods like
     *            PUT
     *            which have path segments that are known only during save
     *            operations
     * @return
     */
    private URI getHref(Map<String, String> hrefParams) {
        // TODO: Get HREF
        return null;
    }

    private boolean isGeneratableResponseType(MediaType responseType) {
        // TODO Auto-generated method stub
        return true;
    }

    private boolean isSupportedRequestType(MediaType requestType) {
        // TODO Auto-generated method stub
        return true;
    }

    /*
     * public void hrefFieldValueChanged(FieldEvent event) { updateHref(); }
     * public void setHref (String href) { if (_Href !.equal href) { final _
     * Href = href; fireHrefChangedEvent(); } }
     * 
     * public void updateHref() { final LinkTemplate linkTemplate =
     * getLinkTemplate(); final ResourceTemplate destination =
     * linkTemplate.getDestination(); final UriTemplate uriTemplate =
     * destination.getUriTemplate(); setHref(uriTemplate.execute(this)); }
     */

}
